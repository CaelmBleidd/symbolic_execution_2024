# Домашнее задание #2. Динамическое символьное  исполнение

Требуется реализовать интерпретатор для динамического символьного исполнения. Для этого предполагается выполнить следующие шаги:

1. Переиспользовать получение SSA представления кода из статического символьного исполнения
2. Переиспользовать Visitor для выражений, составляющих BasicBlocks этого SSA
3. Модифицировать его таким образом, чтобы в результате возвращалась не часть формулы, а множество новых состояний программы после интерпретации некоторой инструкции

4. Реализовать какой-либо алгоритм выбора пути
5. Переиспользовать транслятор из инструкций программы в символичные выражения
6. Реализовать интерпретатор инструкций программы, умеющий работать с вызовами программ
7. Реализовать взаимодействие с символьной памятью

В итоге должен получиться интерпретатор, способный проанализировать все программы из первого домашнего задания. **Результат работы интерпретатора** — набор символьных состояний программы, собранных в терминальных состояниях графа потока управления, "покрывающих" по ветвлениям все пути в программе.

Обязательно должен быть поддержан алиасинг ссылок на объекты -- изменение одного объекта по ссылке может затронуть другие.

## Домашнее задание #2.1. Приоритизация состояний

Требуется модифицировать получившуюся символьную машину, добавив возможность приоритизации состояний. Как было озвучено на лекции, шаг интерпретатора это обработка некоторого символьного состояния, которое было получено из приоритетной очереди. 

Необходимо реализовать следующие функции приоритетов для данной функции: 

1. Fair Random 
2. DFS/BFS
3. Weighter random (NURS) с использованием каких-то дополнительных знаний о пути в программе. Какие это знания -- решите самостоятельно

Для данного и последующих домашних заданий будут добавляться дополнительные тесты. **Неявное требование -- поддержка всех инструкций, которые встречаются в этих тестах.**

Дедлайн -- 27.11.2024

## Домашнее задание #2.2. Интерпретация результатов 
Реализовать компоненту, которая будет способна по символьному состоянию конструировать тест -- запускать анализируемый метод с конкретными аргументами, которые требуются для того чтобы пройти по соответствующему этому состоянию пути.

Дедлайн -- 04.12.2024

## Домашнее задание #2.3. Обработка внешних вызовов

1. Требуется добавить API для взаимодействия с символьной машиной, о котором говорилось на лекции -- `assume(predicate)` и `makeSymbolic(type)`. 

2. Поддержать механизм мокирования вызовов, которые потом можно будет восстановить в тестах. 

3. Добавить возможность добавления аппроксимаций -- какой-то способ сообщить символьной машине, что теперь нужно анализировать другой код вместо своего. Для упрощения поддерживаем два режима -- аппроксимация глобальных функций и классов целиком.  

Дедлайн -- 11.12.2024