# Задание на Path Constraints

Этот файл содержит описание заданий по кодированию ограничений в решатель. Лучше использовать тот же способ общения с решателем, который будет выбран в дальнейшем для реализации символьного интерпретатора.
Сдача домашних заданий происходит при помощи PR в ваш fork данного репозитория.

## 1. Кодирование чисел
В файле [numbers](numbers.go) находится некоторое количество функций. 
Требуется для каждой функции найти все пути исполнения, закодировать в решатель 
соответствующие им ограничения, и вывести значения аргументов, которые позволят пройти по каждому из них (вывести автоматически).

Возвращаемое значение можно игнорировать.

## 1.1 Кодирование нестандартных чисел
В файле [complex](complex.go) представлен тип данных, которого нет в стандартных теориях решаталей. 
Требуется сделать то же самое, что и в прошлом пункте, только придётся свести его к существующим теориям самостоятельно. 
Подумайте, как это сделать так, чтобы этим было удобно пользоваться.

## 2. Работа с массивами
В этом разделе мы познакомимся с массивами, примеры программ лежат в [arrays](arrays.go). 
Примеры состоят из двух частей -- массив примитивов и массив ссылочных объектов.

Глобально, задание остаётся тем же самым, просто кодируемый объект становится чуть сложнее.
Для массивов примитивов всё понятно, для массивов объектов требуется вспомнить то, о чём говорили на лекции. 
Не забывайте, что эта дз будет использоваться как фундамент для последующей кодировки объектов в вашем интерпретаторе.

## 3. Push-pop инкрементальность
Просто научитесь создавать и удалять фреймы из вашего решателя. Реализуйте разные состояния в программе при помощи добавления и удаления ограничений 
из одного решателя, без пересоздания.

## 4. Assumption инкрементальность
Смотрим в файл [softconstraints](softcontraints.go), видим там пример очень похожий на то, что было на лекции. Требуется реализовать механизм "мягких" огранчичений 
при помощи assumptions. Требуется научиться работать с unsat-core -- когда не выполнится нужное ограничение во вложенном 
условии, следует найти конфликт и убрать его из списка ограничений. При этом сохраняем assumption инкрементальность

## 5. Бонус
Я пока не придумал, что давать за бонусные задания, но наверняка это скажется на оценке, если вы что-то не сделаете дальше на курсе.
Если сделаете всё, но без бонусов, то, я думаю, всё равно получите максимальный балл.

Задание заключается в следующем -- возьмите несколько типов (например, пять-десять). Можно взять существующие в стандартной библиотеке, можно придумать свои. 
Подумайте над тем, какими свойствами обладают отношение наследования типов в джаве -- антисимметричность, рефлексивность и тд.
Реализуйте полезные функции, которые позволят задать отношения на типах -- isSubtypeOf, isSupertypeOf, isSubclass (подумайте в чем отличие), 
isInterface и тд. 

Закодируйте вашу систему типов в решатель при помощи этих функций. Должна получиться полурешётка. 

1. Я понимаю, что задание может звучать непонятно и даже пугающе, но я хочу увидеть хотя бы какие-то попытки его выполнить. 2
2. Может быть не ясно вообще, с чего начать, и что использовать. Подсказка -- функции должны работать над неинтерпретированными сортами.
3. Постарайтесь избежать кванторов. Подумайте, как это можно сделать, учитывая имеющиеся ограничения
4. Необязательно кодировать полноценно и идеально, но нужно научиться отвечать на вопрос -- если две каких-то переменных имеют несколько ограничений на типы (например, тип переменной а не подтип Б),
то какого типа может быть а в модели. 
5. Задавайте интересующие вопросы, если не понимаете что делать, можно в личку.
